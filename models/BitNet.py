from tensorflow.keras.callbacks import ModelCheckpoint
from keras.models import Model
from keras.layers import Input, Dense, Dropout, Flatten, LeakyReLU
from keras.layers.convolutional import Conv1D, MaxPooling1D
from tensorflow.keras.optimizers import Adam
import matplotlib.pyplot as plt
from sklearn.metrics import ConfusionMatrixDisplay
from sklearn.metrics import confusion_matrix
from keras.utils.vis_utils import plot_model
from keras.callbacks import Callback
import numpy as np
import pandas as pd
from os import makedirs
from dotenv import load_dotenv
from DataGenerator import BitNet_Generator, get_classweight
from tensorflow.python.framework.ops import disable_eager_execution
import mlflow
from mlflow.models.signature import infer_signature
from shutil import rmtree

disable_eager_execution()

# Params for MLflow
load_dotenv()

Model_Name = 'BitNet.py'
EPOCHS = 100 #@param {type:"slider", min:0, max:1000, step:5}
LEARNING_RATE = 0.0001 #@param {type:"number"}
BATCH_SIZE = 15 #@param {type:"slider", min:0, max:100, step:5}
DROPOUT = 0.6 #@param {type:"slider", min:0, max:1, step:0.01}
ALPHA = 0.001 #@param {type:"number"}
DATASET = "raw" #@param ["raw", "YongImage", "Upsampled"]

makedirs('.BitNet', exist_ok = True)

class_weight = get_classweight(DATASET)
train_generator = BitNet_Generator(BATCH_SIZE, 'train', DATASET)
val_generator = BitNet_Generator(BATCH_SIZE, 'val', DATASET)
test_generator = BitNet_Generator(BATCH_SIZE, 'test', DATASET)

mlflow.set_experiment(Model_Name)
mlflow.start_run()
mlflow.log_artifact(local_path = 'BitNet.py')

mlflow.log_param('dataset',DATASET)
mlflow.log_param('dropout',DROPOUT)
mlflow.log_param('LeakyReLU alpha',ALPHA)
mlflow.log_param('class_weight',class_weight)
mlflow.log_param('epochs',EPOCHS)
mlflow.log_param('batch_size',BATCH_SIZE)
mlflow.log_param('opt_learning_rate',LEARNING_RATE)
mlflow.log_param('opt_name','adam')
mlflow.log_param('steps_per_epoch',int(train_generator.sample_size() // BATCH_SIZE))
mlflow.log_param('validation_steps',int(val_generator.sample_size() // BATCH_SIZE))

def CheckpointCallback():
    return ModelCheckpoint(filepath=".BitNet/Checkpoint",verbose=1,save_weights_only=False,save_best_only=True)

class CustomCallback(Callback):
    def on_epoch_end(self, epoch, logs=None):
        mlflow.log_metrics(logs,epoch)

def BitNet_Model():
  input = Input(shape=(18432,1))
  Conv_layer_1 = Conv1D(filters = 16, kernel_size = 8, activation=LeakyReLU(alpha=0.01), name='Conv_layer_1', strides = 8)(input)
  Conv_layer_2 = Conv1D(filters = 16, kernel_size = 3, activation=LeakyReLU(alpha=0.01), name='Conv_layer_2', strides = 1, padding = 'same')(Conv_layer_1)
  maxpoollayer_1 = MaxPooling1D(pool_size=2, name='maxpoollayer_1')(Conv_layer_2)
  Conv_layer_3 = Conv1D(filters = 32, kernel_size = 3, activation=LeakyReLU(alpha=0.01), name='Conv_layer_3', strides = 2, padding = 'same')(maxpoollayer_1)
  maxpoollayer_2 = MaxPooling1D(pool_size=2, name='maxpoollayer_2')(Conv_layer_3)
  Conv_layer_4 = Conv1D(filters = 64, kernel_size = 3, activation=LeakyReLU(alpha=0.01), name='Conv_layer_4', strides = 2, padding = 'same')(maxpoollayer_2)
  maxpoollayer_3 = MaxPooling1D(pool_size=2, name='maxpoollayer_3')(Conv_layer_4)
  Conv_layer_5 = Conv1D(filters = 128, kernel_size = 3, activation=LeakyReLU(alpha=0.01), name='Conv_layer_5', strides = 2, padding= 'same')(maxpoollayer_3)
  maxpoollayer_4 = MaxPooling1D(pool_size=2, name='maxpoollayer_4')(Conv_layer_5)
  Conv_layer_6 = Conv1D(filters = 128, kernel_size = 3, activation=LeakyReLU(alpha=0.01), name='Conv_layer_6', strides = 2, padding= 'same')(maxpoollayer_4)
  Conv_layer_7 = Conv1D(filters = 128, kernel_size = 3, activation=LeakyReLU(alpha=0.01), name='Conv_layer_7', strides = 2, padding= 'same')(Conv_layer_6)
  flatten = Flatten(name='Flatten_Layer')(Conv_layer_7)
  dropout = Dropout(DROPOUT)(flatten)
  FC_layer_1 = Dense(512, activation=LeakyReLU(alpha=0.01), name="FC_layer_1")(dropout)
  output = Dense(9, activation='softmax' , name="Output_Layer")(FC_layer_1)
  model = Model(inputs=input, outputs=output, name="1D_Model")
  optimiser = Adam(learning_rate=LEARNING_RATE)
  model.compile(loss='categorical_crossentropy', optimizer=optimiser, metrics=['accuracy','Recall','Precision'])
  return model
model = BitNet_Model()

with open('.BitNet/model_summary.txt','w') as f:
    model.summary(print_fn=lambda x: f.write(x + '\n'),show_trainable=True)
mlflow.log_artifact(local_path = '.BitNet/model_summary.txt')
plot_model(model, show_shapes=True, to_file=f'.BitNet/Model_Plot.png')
mlflow.log_artifact(local_path = '.BitNet/Model_Plot.png')

history = model.fit(train_generator, epochs = EPOCHS, verbose = 0, validation_data = val_generator, steps_per_epoch = int(train_generator.sample_size()  // BATCH_SIZE),validation_steps = int(val_generator.sample_size() // BATCH_SIZE), callbacks = [CheckpointCallback(), CustomCallback()], class_weight=class_weight)
mlflow.log_artifact(local_path = '.BitNet/Checkpoint', artifact_path='')

model.load_weights('.BitNet/Checkpoint')
train = train_generator.__getitem__(0)[0]
predictions = model.predict(train)
mlflow.keras.log_model(model,artifact_path='model',signature=infer_signature(train, predictions), registered_model_name=Model_Name)
score = model.evaluate(test_generator,verbose=1)
mlflow.log_metrics({"test_loss": score[0], "test_accuracy": score[1], "test_recall": score[2], "test_precision": score[3]},(EPOCHS-1))
print(f'Test Loss: {score[0]}, Test Accuracy: {score[1]*100}%, Test Recall: {score[2]*100}%, Test Precision: {score[3]*100}%')

def plot_confusion_matrix(model,test_generator):
    title = Model_Name
    labels = ['Ramnit', 'Lollipop', 'Kelihos_ver3', 'Vundo', 'Simda', 'Tracur', 'Kelihos_ver1', 'Obfuscator.ACY', 'Gatak']
    pred = model.predict(test_generator)
    df = pd.DataFrame(index = np.asarray(test_generator.image_filenames).transpose())
    df['pred_label'] = np.argmax(pred, axis=1).transpose()
    df['true_label'] = np.argmax(test_generator.labels, axis=1).transpose()
    df['correct'] = df.apply(lambda row: 1 if row.pred_label == row.true_label else 0, axis=1)
    df.to_csv('.BitNet/predictions.csv')
    mlflow.log_artifact(local_path = '.BitNet/predictions.csv')
    confusion_matrix_ = confusion_matrix(np.argmax(test_generator.labels, axis=1),np.argmax(pred, axis=1),normalize='true')
    confusionMatrixDisplay = ConfusionMatrixDisplay(confusion_matrix_, display_labels=labels)
    fig, ax = plt.subplots(figsize=(20,20))
    label_font = {'size':'18'}
    plt.rcParams.update({'font.size': 14})
    ax.set_xlabel('Predicted labels', fontdict=label_font)
    ax.set_ylabel('Observed labels', fontdict=label_font)
    ax.set_title('Confusion Matrix '+title, fontdict={'size':'22'})
    ax.tick_params(axis='both', which='major', labelsize=14)
    cmD= confusionMatrixDisplay.plot(ax=ax,cmap = plt.get_cmap('Blues'), xticks_rotation='vertical')
    mlflow.log_figure(cmD.figure_, "confusion_matrix.png")

plot_confusion_matrix(model,test_generator)
mlflow.end_run()

rmtree('.BitNet/')