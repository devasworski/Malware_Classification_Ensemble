from tensorflow.keras.utils import Sequence
from sys import path as syspath
from os import path as ospath
syspath.append(ospath.realpath('..'))
from data_processing.preprocessing import bitnet, malvecnet, visnet
import numpy as np
import pandas as pd

def get_classweight(dataset): 
  """
  > The function takes in the name of the dataset and returns a dictionary of class weights. 
  
  The function is used to calculate the class weights for the training data. The class weights are
  used to balance the loss function. 
  
  The function first loads the training labels from the `data/splits/{dataset}/y_train.npy` file. The
  labels are then converted to a pandas dataframe. The dataframe is grouped by the labels and the
  number of samples in each group is calculated. The inverse of the number of samples in each group is
  then calculated and stored in a dictionary. 
  
  The dictionary is then returned. 
  
  The class weights are used in the `fit_model` function.
  
  :param dataset: The name of the dataset you want to train on
  :return: The class weights are being returned.
  """
  ospath.realpath(f'../data/splits/{dataset}/y_train.npy')
  y_train_data = np.load(f'../data/splits/{dataset}/y_train.npy')
  df = pd.DataFrame(np.argmax(y_train_data,axis=1), columns=['lables'])
  F1, F2, F3, F4, F5, F6, F7, F8, F9 = [(1/len(x)) for _, x in df.groupby(df['lables'])]
  return {0:F1, 1:F2, 2: F3, 3:F4, 4:F5, 5:F6, 6:F7, 7:F8, 8:F9}

def __load_presplitt__(dataset,name:str):
  """
  > Loads the pre-split data from the `data/splits` directory
  
  :param dataset: the name of the dataset you want to load
  :param name: the name of the split
  :type name: str
  :return: ids and labels
  """
  ids = np.load(f'../data/splits/{dataset}/x_{name}.npy', allow_pickle=True)
  labels = np.load(f'../data/splits/{dataset}/y_{name}.npy', allow_pickle=True)
  return ids, labels

# > This class is a generator that loads the images from the disk, preprocesses them, and returns them
# in batches
class BitNet_Generator(Sequence):
  def __init__(self, batch_size, folder, dataset):
    image_filenames, labels = __load_presplitt__(dataset,folder)
    self.image_filenames = image_filenames
    self.labels = labels
    self.batch_size = batch_size
    self.folder = folder
  
  def __len__(self) :
    return (np.ceil(len(self.image_filenames) / float(self.batch_size))).astype(int)

  def __getitem__(self, idx) :
    batch_x = self.image_filenames[idx * self.batch_size : (idx+1) * self.batch_size]
    batch_y = self.labels[idx * self.batch_size : (idx+1) * self.batch_size]
    return np.array([np.asarray(bitnet.preprocess(file_name,origin_folder='../data/BIG_2015/train',dest_folder='../data/BitNet'),dtype='float64') for file_name in batch_x]).reshape(-1,18432,1), np.array(batch_y)

  def sample_size(self):
    return len(self.image_filenames)

# > This class is a generator that loads the data from the disk, preprocesses it, and returns it in
# batches
class MalVecNet_Generator(Sequence):
  def __init__(self, batch_size, folder, dataset):
    image_filenames, labels = __load_presplitt__(dataset,folder)
    self.image_filenames = image_filenames
    self.labels = labels
    self.batch_size = batch_size
    self.folder = folder
  
  def __len__(self) :
    return (np.ceil(len(self.image_filenames) / float(self.batch_size))).astype(int)

  def __getitem__(self, idx) :
    batch_x = self.image_filenames[idx * self.batch_size : (idx+1) * self.batch_size]
    batch_y = self.labels[idx * self.batch_size : (idx+1) * self.batch_size]
    return np.array([np.asarray(malvecnet.preprocess(file_name,origin_folder='../data/BIG_2015/train',dest_folder='../data/MalVecNet')) for file_name in batch_x]).reshape(-1,3200, 8,1), np.array(batch_y)

  def sample_size(self):
    return len(self.image_filenames)

# > This class is a generator that loads the data from the disk, preprocesses it, and returns it in
# batches
class VisNet_Generator(Sequence):
  def __init__(self, batch_size, folder, dataset):
    image_filenames, labels = __load_presplitt__(dataset,folder)
    self.image_filenames = image_filenames
    self.labels = labels
    self.batch_size = batch_size
    self.folder = folder
  
  def __len__(self) :
    return (np.ceil(len(self.image_filenames) / float(self.batch_size))).astype(int)

  def __getitem__(self, idx) :
    batch_x = self.image_filenames[idx * self.batch_size : (idx+1) * self.batch_size]
    batch_y = self.labels[idx * self.batch_size : (idx+1) * self.batch_size]
    return np.array([np.asarray(visnet.preprocess(file_name,origin_folder='../data/BIG_2015/train',dest_folder='../data/VisNet'),dtype='float64') for file_name in batch_x]).reshape(-1,1282), np.array(batch_y)

  def sample_size(self):
    return len(self.image_filenames)

# This class is a generator that will return a batch
# of data from the folder, with the data preprocessed for the three networks
class Ensemble_Generator(Sequence):
  def __init__(self, batch_size, folder, dataset):
    image_filenames, labels = __load_presplitt__(dataset,folder)
    self.image_filenames = image_filenames
    self.labels = labels
    self.batch_size = batch_size
    self.folder = folder
  
  def __len__(self) :
    return (np.ceil(len(self.image_filenames) / float(self.batch_size))).astype(int)

  def __getitem__(self, idx) :
    batch_x = self.image_filenames[idx * self.batch_size : (idx+1) * self.batch_size]
    batch_y = self.labels[idx * self.batch_size : (idx+1) * self.batch_size]
    x = [np.asarray([np.asarray(bitnet.preprocess(file_name,origin_folder='../data/BIG_2015/train',dest_folder='../data/BitNet'),dtype='float64') for file_name in batch_x]).reshape(-1,18432,1), np.asarray([np.asarray(malvecnet.preprocess(file_name,origin_folder='../data/BIG_2015/train',dest_folder='../data/MalVecNet'),dtype='float64') for file_name in batch_x]).reshape(-1,3200, 8,1), np.array([np.asarray(visnet.preprocess(file_name,origin_folder='../data/BIG_2015/train',dest_folder='../data/VisNet'),dtype='float64') for file_name in batch_x]).reshape(-1,1282)]
    y = [batch_y,batch_y,batch_y,batch_y]
    return x, y
    
  def sample_size(self):
    return len(self.image_filenames)