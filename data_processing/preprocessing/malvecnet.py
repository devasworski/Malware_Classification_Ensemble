import numpy as np
import re
from pyparsing import Word, hexnums, WordEnd, Optional, alphas, alphanums, printables, ParseException
import os

MAX_OPCODE_LENGHT = 64
NUMBER_OF_INSTRUCTIONS = 3200

regex = re.compile(r'[\n\r\t\?\;\_\'\-]')
hex_integer = Word(hexnums) + WordEnd()
search = Optional('.') + Word(alphas,alphanums)('section') + ":" + hex_integer('adress') + Optional((hex_integer*(1,))("instructions") + Word(alphas,alphanums)("opcode")) + Optional(Word(alphas,alphanums)('first_operant')) + Optional("," + Word(printables)('second_operant'))

PROCESS_VERSION = 3

empty_files_counter = 0
empty_file_ids = []

small_files_counter = 0
small_file_ids = []

super_small_files_counter = 0
super_small_file_ids = []

def pad(A, length):
    arr = np.zeros(length)
    arr[:len(A)] = A
    return arr

def pad2D(A, height, width):
    c_height, c_width = A.shape
    return np.pad(A, ((0,(height-c_height)),(0,width-c_width)), 'constant')

def asm_to_np(file):
    RESULT = []
    counter = 0
    counter_2 = 0
    for line in file.readlines():
            line = regex.sub(" ", line)
            try:
                line = search.parseString(line)
                section = line.section.encode(encoding = 'ASCII', errors = 'ignore')
                adress = bytes.fromhex(''.join(line.adress.asList() if not line.adress == None else ''))
                opcode = line.opcode.encode(encoding = 'ASCII', errors = 'ignore') if not line.opcode == '' else ' '.encode(encoding = 'ASCII', errors = 'ignore')
                operants = f'{line.first_operant},{line.second_operant}'.encode(encoding = 'ASCII', errors = 'ignore')
                instructions = bytes.fromhex(''.join(line.instructions.asList() if not line.instructions == '' else ''))
                byteline = section[1].to_bytes(1, byteorder='big')+adress[2:]+instructions[:4]+opcode[0].to_bytes(1, byteorder='big')+operants
                np_array = np.frombuffer(byteline, dtype='uint8')
                np_array = pad(np_array[0:int(MAX_OPCODE_LENGHT/8)],int(MAX_OPCODE_LENGHT/8))
                RESULT.append(np_array)
                counter += 1
                if counter >= NUMBER_OF_INSTRUCTIONS: break 
            except ParseException as e:
                continue
            except ValueError as e:
                continue
            counter_2 += 1
            if counter_2 >= 12000:
                break
    RESULT = pad2D(np.asarray(RESULT)[:NUMBER_OF_INSTRUCTIONS,:int(MAX_OPCODE_LENGHT/8)],NUMBER_OF_INSTRUCTIONS,int(MAX_OPCODE_LENGHT/8))
    return RESULT

def preprocess(file_name:str, origin_folder:str, dest_folder:str):
    asm_path = f"{origin_folder}/{file_name}.asm"
    vec_path = f"{dest_folder}/{PROCESS_VERSION}/{file_name}_{NUMBER_OF_INSTRUCTIONS}_{int(MAX_OPCODE_LENGHT/8)}.npy"
    if not os.path.exists(vec_path):    
        f = open(asm_path, "r", encoding = 'unicode_escape', errors='ignore')
        output = asm_to_np(f)
        np.save(vec_path,output)
    else:
        output = np.load(vec_path)
    return output